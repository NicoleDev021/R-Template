# SPDX-FileCopyrightText: Copyright (c) 2025 Madison Nicole Goodwin https://github.com/NicoleDev021
# SPDX-License-Identifier: GPL-3.0-or-later

name: "R Comprehensive Security & Analysis"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 1'  # Weekly on Monday at 2 AM

jobs:
  r-security-analysis:
    name: R Security & Code Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    permissions:
      contents: read
      security-events: write
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # FILESYSTEM SECURITY SCANNING (No R setup required)
    - name: Run Trivy filesystem vulnerability scan
      continue-on-error: true
      id: trivy-scan
      uses: aquasecurity/trivy-action@0.32.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy results to GitHub Security tab
      continue-on-error: true
      if: steps.trivy-scan.outcome != 'skipped'
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'
    
    # R ENVIRONMENT SETUP (Required for R-specific security checks)
    - name: Setup R
      uses: r-lib/actions/setup-r@v2
      with:
        r-version: 'release'
        use-public-rspm: true
    
    - name: Cache R packages
      uses: actions/cache@v4
      with:
        path: ${{ env.R_LIBS_USER }}
        key: ${{ runner.os }}-R-${{ hashFiles('renv.lock') }}
        restore-keys: ${{ runner.os }}-R-

    - name: Restore renv environment
      id: renv-restore
      run: |
        if (!requireNamespace("renv", quietly = TRUE)) {
          install.packages("renv", type = "source")
        }
        renv::restore()
        cat("‚úì renv environment restored successfully\n")
      shell: Rscript {0}
    
    # R PACKAGE SECURITY SCANNING (Requires R environment)
    - name: R package security audit with oysteR
      continue-on-error: true
      id: oyster-audit
      run: |
        tryCatch({
          library(oysteR)
          
          # Audit renv.lock
          audit_results <- audit_renv_lock("renv.lock")
          saveRDS(audit_results, "oyster-audit-results.rds")
          
          # Check for vulnerabilities
          if (length(audit_results) > 0) {
            cat("::warning::Security vulnerabilities found in R packages\n")
            print(audit_results)
          } else {
            cat("‚úì No security vulnerabilities found\n")
          }
          
          # Check for package updates
          old_pkgs <- old.packages()
          if (!is.null(old_pkgs) && nrow(old_pkgs) > 0) {
            cat("::warning::R package updates available - consider updating\n")
            write.csv(old_pkgs, "r-package-updates.csv", row.names = FALSE)
          } else {
            cat("‚úì All R packages are up to date\n")
          }
          
        }, error = function(e) {
          cat("::error::R package security audit failed:", e$message, "\n")
        })
      shell: Rscript {0}
    
    # CODE QUALITY ANALYSIS (Requires R environment)
    - name: Run R code linting
      continue-on-error: true
      id: lintr-check
      run: |
        tryCatch({
          library(lintr)
          lint_results <- lint_dir(".")
          saveRDS(lint_results, "lintr-results.rds")
          
          if (length(lint_results) > 0) {
            cat("::warning::Code linting issues found\n")
            print(summary(lint_results))
          } else {
            cat("‚úì No linting issues found\n")
          }
          
        }, error = function(e) {
          cat("::warning::R code linting failed:", e$message, "\n")
        })
      shell: Rscript {0}
    
    - name: Check code complexity
      continue-on-error: true
      id: complexity-check
      run: |
        tryCatch({
          library(cyclocomp)
          
          r_files <- list.files(pattern = "\\.[Rr]$", recursive = TRUE, full.names = TRUE)
          r_files <- r_files[!grepl("renv/|packrat/|\\.git/", r_files)]
          
          if (length(r_files) > 0) {
            complexity_results <- data.frame()
            
            for (file in r_files) {
              tryCatch({
                if (file.exists(file)) {
                  complexity <- cyclocomp(file)
                  if (length(complexity) > 0 && !is.null(complexity)) {
                    file_complexity <- data.frame(file = file, complexity = complexity)
                    complexity_results <- rbind(complexity_results, file_complexity)
                  }
                }
              }, error = function(e) {
                cat("Warning: Could not analyze", file, "\n")
              })
            }
            
            if (nrow(complexity_results) > 0) {
              saveRDS(complexity_results, "complexity-results.rds")
              
              high_complexity <- complexity_results[complexity_results$complexity > 15, ]
              if (nrow(high_complexity) > 0) {
                cat("::warning::High complexity functions found\n")
                print(high_complexity)
              } else {
                cat("‚úì All functions have acceptable complexity\n")
              }
            } else {
              cat("No complexity data available\n")
            }
          } else {
            cat("No R files found for complexity analysis\n")
          }
          
        }, error = function(e) {
          cat("::warning::Code complexity analysis failed:", e$message, "\n")
        })
      shell: Rscript {0}
    
    # REPORTING
    - name: Generate comprehensive report
      if: always()
      run: |
        cat > security-analysis-report.md << 'EOF'
        # R Security & Analysis Report
        
        Generated: $(date)
        
        ## Environment
        $(R --version | head -1)
        
        ## Analysis Results Summary
        
        | Component | Status | Notes |
        |-----------|--------|-------|
        | renv Restore | ${{ steps.renv-restore.outcome }} | Environment restoration |
        | Trivy Scan | ${{ steps.trivy-scan.outcome }} | Filesystem vulnerabilities |
        | oysteR Audit | ${{ steps.oyster-audit.outcome }} | R package security |
        | Code Linting | ${{ steps.lintr-check.outcome }} | Code quality |
        | Complexity Check | ${{ steps.complexity-check.outcome }} | Code complexity |
        
        ## Detailed Findings
        
        EOF
        
        [ -f "oyster-audit-results.rds" ] && echo "- ‚úì R package security audit completed" >> security-analysis-report.md
        [ -f "lintr-results.rds" ] && echo "- ‚úì Code linting analysis completed" >> security-analysis-report.md
        [ -f "complexity-results.rds" ] && echo "- ‚úì Code complexity analysis completed" >> security-analysis-report.md
        [ -f "trivy-results.sarif" ] && echo "- ‚úì Filesystem vulnerability scan completed" >> security-analysis-report.md
        
        cat security-analysis-report.md
    
    - name: Upload analysis artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: r-security-analysis-results-${{ github.run_id }}
        path: |
          security-analysis-report.md
          r-package-updates.csv
          *-results.rds
          trivy-results.sarif
          *.log
        retention-days: 30
    
    - name: Create security analysis issue (only if issues found)
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Check step outcomes to determine if we need to create an issue
          const steps = {
            'renv Restore': '${{ steps.renv-restore.outcome }}',
            'Trivy Scan': '${{ steps.trivy-scan.outcome }}',
            'oysteR Security Audit': '${{ steps.oyster-audit.outcome }}',
            'Code Linting': '${{ steps.lintr-check.outcome }}',
            'Complexity Check': '${{ steps.complexity-check.outcome }}'
          };
          
          let hasFailures = false;
          let hasWarnings = false;
          
          for (const [step, outcome] of Object.entries(steps)) {
            if (outcome === 'failure') hasFailures = true;
            if (outcome === 'skipped' || outcome === 'cancelled') hasWarnings = true;
          }
          
          // Only create issue if there are problems
          if (!hasFailures && !hasWarnings) {
            console.log('‚úÖ All security scans passed successfully - no issue will be created');
            console.log('üìÅ Detailed results are still available in workflow artifacts');
            return;
          }
          
          // Determine trigger context
          let triggerInfo = '';
          let titlePrefix = '';
          
          if (context.eventName === 'pull_request') {
            titlePrefix = '[PR Security Analysis]';
            triggerInfo = `**Triggered by:** Pull Request #${context.payload.pull_request.number}\n`;
            triggerInfo += `**PR Title:** ${context.payload.pull_request.title}\n`;
            triggerInfo += `**PR Link:** ${context.payload.pull_request.html_url}\n\n`;
          } else if (context.eventName === 'push') {
            titlePrefix = '[Push Security Analysis]';
            triggerInfo = `**Triggered by:** Push to main branch\n`;
            triggerInfo += `**Commit:** ${context.sha.substring(0, 7)}\n`;
            triggerInfo += `**Commit Link:** ${context.payload.repository.html_url}/commit/${context.sha}\n\n`;
          } else if (context.eventName === 'schedule') {
            titlePrefix = '[Scheduled Security Analysis]';
            triggerInfo = `**Triggered by:** Scheduled scan (Weekly Monday 2 AM UTC)\n`;
            triggerInfo += `**Repository:** ${context.payload.repository.full_name}\n\n`;
          }
          
          let issueBody = `## üîí R Security & Analysis Report\n\n`;
          issueBody += triggerInfo;
          
          issueBody += '### Analysis Results Summary\n\n';
          issueBody += '| Component | Status |\n|-----------|--------|\n';
          
          for (const [step, outcome] of Object.entries(steps)) {
            const emoji = outcome === 'success' ? '‚úÖ' : outcome === 'failure' ? '‚ùå' : '‚ö†Ô∏è';
            issueBody += `| ${step} | ${emoji} ${outcome} |\n`;
          }
          
          issueBody += '\nüìÅ **Detailed results available in workflow artifacts**\n';
          issueBody += `üîó [View full analysis](${context.payload.repository.html_url}/actions/runs/${context.runId})\n\n`;
          
          // Read report if available
          if (fs.existsSync('security-analysis-report.md')) {
            const report = fs.readFileSync('security-analysis-report.md', 'utf8');
            issueBody += '<details><summary>üìã Full Report</summary>\n\n```\n' + report + '\n```\n</details>\n\n';
          }
          
          // Add action items based on results
          issueBody += '### üìã Recommended Actions\n\n';
          
          if (hasFailures) {
            issueBody += 'üö® **High Priority:**\n';
            issueBody += '- Review failed security scans immediately\n';
            issueBody += '- Check workflow artifacts for detailed error information\n';
            issueBody += '- Address any security vulnerabilities found\n\n';
          }
          
          if (hasWarnings) {
            issueBody += '‚ö†Ô∏è **Medium Priority:**\n';
            issueBody += '- Review skipped or cancelled scan steps\n';
            issueBody += '- Ensure all security tools are functioning properly\n\n';
          }
          
          // Add automation note
          issueBody += '---\n\n';
          issueBody += '*This issue was automatically created by the R Security Analysis workflow. ';
          issueBody += 'You can close this issue once you have reviewed the results.*';
          
          // Determine issue title and labels
          let issueTitle = `${titlePrefix} Security Analysis Report - ${new Date().toISOString().split('T')[0]}`;
          let labels = ['security', 'automated'];
          
          if (hasFailures) {
            labels.push('high-priority');
            issueTitle += ' ‚ö†Ô∏è Issues Found';
          } else if (hasWarnings) {
            labels.push('medium-priority');
            issueTitle += ' ‚ö†Ô∏è Warnings';
          }
          
          // Create the issue
          const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: issueTitle,
            body: issueBody,
            labels: labels
          });
          
          console.log(`Created security analysis issue: ${issue.data.html_url}`);
